import Foundation
import SwiftData

/// Nudge generated by the LLM.
struct SmartNudge {
    let type: NudgeType
    let message: String
    let targetItemID: UUID?
}

/// Protocol for testability.
protocol SmartNudgeServiceProtocol {
    @MainActor func generateSmartNudge(context: ModelContext) async -> SmartNudge?
}

/// LLM-backed nudge generator. Sends a summary of the user's boards, recent items,
/// and engagement stats to the LLM, which returns a single contextual nudge.
/// Falls back silently if AI is disabled or the LLM fails.
final class SmartNudgeService: SmartNudgeServiceProtocol {
    private let provider: LLMProvider

    init(provider: LLMProvider = LLMServiceConfig.makeProvider()) {
        self.provider = provider
    }

    @MainActor func generateSmartNudge(context: ModelContext) async -> SmartNudge? {
        guard LLMServiceConfig.isConfigured else { return nil }

        let boards = (try? context.fetch(FetchDescriptor<Board>())) ?? []
        let allItems = (try? context.fetch(FetchDescriptor<Item>())) ?? []

        let twoWeeksAgo = Calendar.current.date(byAdding: .day, value: -AppConstants.Days.stale, to: .now) ?? .now
        let recentItems = allItems.filter { $0.createdAt > twoWeeksAgo && $0.status != .dismissed }

        guard !recentItems.isEmpty else { return nil }

        let systemPrompt = buildSystemPrompt()
        let userPrompt = buildUserPrompt(boards: boards, recentItems: recentItems, allItems: allItems)

        guard let result = await provider.complete(system: systemPrompt, user: userPrompt, service: "nudges") else {
            return nil
        }

        return parseResponse(result.content, allItems: allItems)
    }

    // MARK: - Prompt Building

    private func buildSystemPrompt() -> String {
        """
        You are a knowledge management assistant for a personal learning tool called Grove.
        The user saves articles, videos, notes, and lectures, then reflects on them by writing
        key insights, questions, disagreements, and connections.

        Generate ONE nudge to help the user deepen their learning. Return JSON only:
        {
          "type": "reflection_prompt" | "contradiction" | "knowledge_gap" | "synthesis_prompt" | "course_continue",
          "message": "The nudge message, 1-2 sentences, referencing specific item titles",
          "target_item_title": "Exact title of the most relevant item, or null"
        }

        Nudge types:
        - reflection_prompt: Suggest the user reflect on a specific unreflected item
        - contradiction: Point out potential tension between two items the user saved
        - knowledge_gap: Identify a topic the user is exploring but may be missing a perspective on
        - synthesis_prompt: Suggest combining insights from multiple items on a topic
        - course_continue: Encourage continuing a learning path or course

        Rules:
        - Reference specific item titles in the message
        - Be concise and specific â€” no generic advice
        - Prefer items the user hasn't reflected on yet
        - If items seem contradictory, highlight the contradiction
        - Return valid JSON only, no markdown fences
        """
    }

    @MainActor private func buildUserPrompt(boards: [Board], recentItems: [Item], allItems: [Item]) -> String {
        var parts: [String] = []

        // Board summaries
        let boardSummaries = boards.prefix(15).map { board in
            let itemCount = board.items.count
            let reflectedCount = board.items.filter { !$0.reflections.isEmpty }.count
            return "- \(board.title): \(itemCount) items, \(reflectedCount) reflected"
        }.joined(separator: "\n")
        parts.append("BOARDS:\n\(boardSummaries)")

        // Recent items with reflection status
        let itemList = LLMContextBuilder.itemList(Array(recentItems.prefix(30)))
        parts.append("RECENT ITEMS (last 2 weeks):\n\(itemList)")

        // Engagement stats
        let totalItems = allItems.count
        let reflectedItems = allItems.filter { !$0.reflections.isEmpty }.count
        let totalConnections = allItems.reduce(0) { $0 + $1.outgoingConnections.count }
        let inboxCount = allItems.filter { $0.status == .inbox }.count
        parts.append("STATS: \(totalItems) total items, \(reflectedItems) reflected, \(totalConnections) connections, \(inboxCount) in inbox")

        return parts.joined(separator: "\n\n")
    }

    // MARK: - Response Parsing

    private func parseResponse(_ content: String, allItems: [Item]) -> SmartNudge? {
        guard let response: SmartNudgeResponse = LLMJSONParser.decode(SmartNudgeResponse.self, from: content) else {
            return nil
        }

        let nudgeType = mapType(response.type)
        let message = response.message

        // Resolve target item by title match
        var targetItemID: UUID?
        if let targetTitle = response.target_item_title {
            targetItemID = allItems.first(where: {
                $0.title.lowercased() == targetTitle.lowercased()
            })?.id
        }

        return SmartNudge(type: nudgeType, message: message, targetItemID: targetItemID)
    }

    private func mapType(_ typeString: String) -> NudgeType {
        switch typeString {
        case "reflection_prompt": return .reflectionPrompt
        case "contradiction": return .contradiction
        case "knowledge_gap": return .knowledgeGap
        case "synthesis_prompt": return .synthesisPrompt
        case "course_continue": return .continueCourse
        default: return .reflectionPrompt
        }
    }
}

// MARK: - Response Model

private struct SmartNudgeResponse: Decodable {
    let type: String
    let message: String
    let target_item_title: String?
}
